#!/usr/bin/env node

const debug = require('debug')
const _ = require('lodash')
const yargs = require('yargs/yargs')(process.argv.slice(2))
const DiscordFS = require('../src/discordFS/')
const HTTPServer = require('../src/httpServer')

debug.enable('*') // Enable logging

//
// Disable Experimental features warning
//
const { emitWarning } = process;

process.emitWarning = (warning, ...args) => {
    const warningsToIgnore = ['buffer.Blob is an experimental feature. This feature could change at any time']
    if (warningsToIgnore.includes(warning)) return
    return emitWarning(warning, ...args);
};

// Parse option
// Env vars will be parsed as option
// ie DDRIVE_HTTP_PORT will be parsed as httpPort
const args = yargs
    .env('DDRIVE')
    .option('httpPort', {
        alias: 'P',
        describe: 'Port of HTTP server',
        type: 'number',
    })
    .option('auth', {
        alias: 'A',
        describe: 'Username password separated by ":". ie - admin:password',
        type: 'string',
    })
    .option('token', {
        alias: 'T',
        describe: 'Discord bot/user token',
        required: true,
        type: 'string',
    })
    .option('channelId', {
        alias: 'C',
        describe: 'Text channel id where data will be stored',
        required: true,
        type: 'string',
    })
    .option('timeout', {
        describe: 'Time in ms before upload request to discord server will be aborted. Increase it if you have slow internet',
        required: false,
        type: 'number',
    })
    .option('chunkSize', {
        describe: 'Size of chunk (part) to be uploaded to discord in bytes. Max 8MB for bot token and 500MB for nitro user token',
        required: false,
        type: 'number'
    })
    .options('metadata', {
        describe: 'Enables route /metadata where all the file metadata will be sent as json',
        required: false,
        type: 'string'
    })
    .config()
    .argv

// Extract arguments
const {
    token, auth, channelId, httpPort = parseInt(process.env.PORT, 10), metadata
} = args

// Parse chunkSize and timeout, if invalid value set to default
let { chunkSize, timeout } = args
chunkSize = parseInt(chunkSize, 10)
if(!_.isFinite(chunkSize) || chunkSize < 1) chunkSize = undefined
timeout = parseInt(timeout, 10)
if(!_.isFinite(timeout) || timeout < 1) timeout = undefined

//
// App entry point
//
const startApp = async () => {
    // Boot discordFS
    const discordFS = new DiscordFS({ token, channelId, chunkSize, rest: { timeout } })
    await discordFS.load() // Build file index

    // Create HTTP Server
    const httpServer = new HTTPServer(discordFS, { httpPort, auth, metadata })
    httpServer.build()
}

// Start app
startApp()
    .then()
    .catch((err) => {
        const appDebug = debug('app')
        if (err.message.includes('Unknown Channel')) appDebug(`=== APP CRASHED :: INVALID CHANNEL_ID`)
        else if (err.message.includes('Unauthorized')) appDebug('=== APP CRASHED :: INVALID TOKEN')
        else appDebug('=== APP CRASHED :: UNKNOWN ERROR === \n', err)
    })
